[{"content":"Lab 02 Assignment 题面与所有提及的文件均保存在作者的GitHub中，点击这里查看。\nQuestion 01 1. 注释标记的哪些行会导致编译错误？将错误截图，并说明原因。 第 4 行会编译错误。\n在方法中声明的变量需手动设置初始值后方可正常调用，此处 m 没有赋初始值。\n2. 区分变量 x 和 m ，回答谁需要初始化才能使用，为什么 m需要初始化才能使用，因为它是声明在方法中的局部变量。\nx不需初始化即可使用，因为它是声明在类中的全局变量。\nQuestion 02 a. Overload(int m) 与 Overload(double m) 互为重载的构造方法。 正确。\nb. int Overload(int m) 与 void Overload(double m) 互为重载的非构造方法。 正确。\nc. Overload 类有 2 个构造方法，尝试调用默认构造方法 Overload() 会无法通过编译。 正确。\nd. Overload 类有 3 个构造方法。 错误。构造方法无返回值类型，只有前两个方法是合法的构造方法。\nQuestion 03 输出：\ninitialize A1 initialize A2 initialize A3 initialize A4 initialize A5 initialize A6 copy from A6 initialize B1 initialize A8 main begins initialize A9 initialize A6 copy from A6 initialize B2 initialize A8 main ends Question 04 1. 这段代码能够证明“在属性定义处初始化的属性，比在方法中初始化的属性先被初始化”吗？ 能。 a7在属性定义处初始化，a8在方法中初始化，尽管a7出现于a8之后，依然被先初始化。\n2. 这段代码能够证明“在属性定义处初始化的属性，初始化顺序等同于他们在类定义 中出现的顺序”吗？\n能。 a6、a7两个非静态属性先后出现，二者也是按照出现顺序先后被初始化。\nQuestion 05 静态属性的初始化顺序均与出现顺序相同，无论是静态变量还是静态初始化块。\n静态变量 静态变量在类加载时初始化。它们按照在类中出现的顺序进行初始化。 静态初始化块 静态初始化块在静态变量初始化同时执行。多个静态初始化块按照它们在类中出现的顺序依次执行。 a3, a4, a5中，a3，a5是静态变量、a4在静态初始化块中被初始化，三者均按照出现顺序a3 - a4 - a5被初始化。\nQuestion 06 1. 这段代码能够证明“在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”吗？如果不能，请尝试修改代码并证明。 不能。 需要在每个类的起始处打印执行的提示信息，修改后的代码如下：\nclass A { static { System.out.println(\u0026#34;Class A is being loaded\u0026#34;); } int value; static A a1 = new A(1); public A(int i) { System.out.println(\u0026#34;initialize A\u0026#34; + i); value = i; } public A(A a) { System.out.println(\u0026#34;copy from A\u0026#34; + a.value); value = a.value; } static A a2 = new A(2); } class B { static { System.out.println(\u0026#34;Class B is being loaded\u0026#34;); } A a8; // A a7 = new A(a6); A a6 = new A(6); static A a3 = new A(3); static A a4; static { a4 = new A(4); } static A a5 = new A(5); public B(int i) { System.out.println(\u0026#34;initialize B\u0026#34; + i); a8 = new A(8); } A a7 = new A(a6); } public class Initialization { static { System.out.println(\u0026#34;Class Initialization is being loaded\u0026#34;); } static B b1 = new B(1); static B b2; public static void main(String[] args) { System.out.println(\u0026#34;main begins\u0026#34;); A a9 = new A(9); b2 = new B(2); System.out.println(\u0026#34;main ends\u0026#34;); } } 该程序编译运行后输出结果：\nClass Initialization is being loaded Class B is being loaded Class A is being loaded initialize A1 initialize A2 initialize A3 initialize A4 initialize A5 initialize A6 copy from A6 initialize B1 initialize A8 main begins initialize A9 initialize A6 copy from A6 initialize B2 initialize A8 main ends 由前三行可知，类被加载的顺序是Initialization, B, A, 与三者第一次被加载的顺序一致，故可以证明“在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”。\n2. 基于static关键字，带有static关键字的方法、变量、代码块可以调用什么？反过来，不带有static关键字的方法、变量、代码块可以调用什么？(带有static关键字的方法、变量 or 不带有static关键字的方法、变量 or 都可以) 带有static关键字的方法、变量、代码块只能调用其他带有static关键字的方法、变量、代码块。\n不带有static关键字的方法、变量、代码块可以调用带有static关键字的方法、变量、代码块，也可以调用其他不带static关键字的方法、变量、代码块。\nQuestion 07 不可以，其他的外部类不能通过 new Singleton() 来构造一个新的 Singleton 变量。\nQuestion 08 因为 Singleton 类的构造方法是私有的，此类只能在 Singleton 类的内部被调用。外部类无法访问这个私有构造方法，因此无法创造更多实例，最多只可能有由 Singleton 类自己创造的 1 个实例同时存在。\n唯一实例在第一次调用 getInstance() 方法时被构造。\nQuestion 09 下列代码可以从外部调用 Singleton 类的 foo()：\npublic class TestSingleton { public static void main(String[] args) { // 获取 Singleton 类的唯一实例 Singleton singletonInstance = Singleton.getInstance(); // 调用 Singleton 类的 foo() 方法 singletonInstance.foo(); } } Question 10 代码见./Q10/TestPerson.java, 点此跳转\nQuestion 11 代码见./Q11/Solution.java, 点此跳转\n","date":"2024-11-06T00:00:00Z","permalink":"https://charactex.com/post/2024/11/oop-lab02/","title":"北航软工: 面向对象程序设计 Lab02"},{"content":" 题面与所有提及的文件均保存在作者的GitHub中，点击这里查看。\nLab 01 Assignment Question 01 包名命名为Q1，在命令行使用javac Q1/Main.java命令编译，并使用java Q1.Main命令运行生成的字节码。\nQuestion 02 基本类型 默认值 基本类型 默认值 byte 0 boolean false short 0 char 0 int 0 float 0.0 long 0 double 0.0 代码实现：\npublic class Main { byte b; short s; int i; long l; boolean bool; char c; float f; double d; public static void main(String[] args) { Main m = new Main(); System.out.println(\u0026#34;byte: \u0026#34; + m.b); System.out.println(\u0026#34;short: \u0026#34; + m.s); System.out.println(\u0026#34;int: \u0026#34; + m.i); System.out.println(\u0026#34;long: \u0026#34; + m.l); System.out.println(\u0026#34;bool: \u0026#34; + m.bool); System.out.println(\u0026#34;char: \u0026#34; + (int)m.c); System.out.println(\u0026#34;float: \u0026#34; + m.f); System.out.println(\u0026#34;double: \u0026#34; + m.d); } } 保存在./Q2/Main.java。\nQuestion 03 初步体现了面向对象编程思想，代码实现\npublic class FindMinMax { private static final double d1 = 1, d2 = -9.9, d3 = 96.9; public static double max() { double tmp; tmp = d1 \u0026gt; d2? d1 : d2; return (tmp \u0026gt; d3? tmp : d3); } public static double min() { double tmp; tmp = d1 \u0026lt; d2? d1 : d2; return (tmp \u0026lt; d3? tmp : d3); } public static void main(String[] args) { System.out.println(\u0026#34;max = \u0026#34; + max()); System.out.println(\u0026#34;min = \u0026#34; + min()); } } 保存在./Q3/FindMinMax.java，运行结果：\nmax = 96.9 min = -9.9 Question 04 运行结果：\n1 2 b is false 在main方法中，首先执行test1(0)，函数打印1并返回0 \u0026lt; 1的boolean值true；\n其次执行test2(2)，函数打印2并返回 2 \u0026lt; 2 的boolean值 false 。\n因为 test2(2) 为 false ，故 b = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2) 一定为false。由于短路机制的存在，将不会继续运行test3(2)函数，故没有在屏幕上输出3。\nQuestion 05 1. 上述源文件的名字是什么？ 答：Student.java\n2. 编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？ 答：生成 2 个字节码文件，文件名分别为Student.class与Exam.class。\n3. 执行以下命令并输出结果 （1）在命令行执行 java Student 得到怎样的错误提示？ Error: Main method not found in class Student, please define the main method as: public static void main(String[] args) or a JavaFX application class must extend javafx.application.Application （2）执行 java exam 得到怎样的错误提示？ Error: Could not find or load main class exam Caused by: java.lang.NoClassDefFoundError: exam (wrong name: Q5/Exam) （3）执行 java Exam.class 得到怎样的错误提示？ Error: Could not find or load main class Exam.class Caused by: java.lang.ClassNotFoundException: Exam.class （4）执行 java Exam 得到怎样的输出结果？ I am studying Java. Question 06 代码见./Q6/TwoDimensionArray.java\n运行结果：\nb[0][0] = 1000 sum = 1139 b.lengh = 3 arr1: 0 1 2 3 4 5 6 7 8 9 10 11 arr2: 0 1 2 3 4 5 6 7 8 9 10 11 arr3: 0 1 2 3 4 5 6 7 8 Question 07 题设代码： public class SwitchExample { public static void main (String[] args) { char c = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt;= 4; i++) { switch (i) { case 1: c = \u0026#39;J\u0026#39;; System.out.print(c); case 2: c = \u0026#39;e\u0026#39;; System.out.print(c); break; case 3: c = \u0026#39;p\u0026#39;; System.out.print(c); default: System.out.print(\u0026#34;好\u0026#34;); } } } } 运行结果： Jeep好好 原因分析： i = 1时，switch-case语句进入case 1，输出J；由于没有break语句，继续向下执行，输出e，然后break跳出switch-case，继续下一轮循环。\ni = 2时，switch-case语句进入case 2，输出e，之后遇到break语句，跳出switch-case，继续下一轮循环。\ni = 3时，switch-case语句进入case 3，输出p；由于没有break语句，继续向下执行default的内容，输出好。\ni = 4时，switch-case语句进入default，输出好；之后到达switch-case末尾，不再执行。\n故输出为Jeep好好。\nQuestion 08 代码见./Q8/nDimension.java\nimport java.util.Scanner; public class nDimension { public static void main(String[] args) { Scanner input = new Scanner(System.in); int n = input.nextInt(); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { System.out.print(++cnt + \u0026#34; \u0026#34;); } System.out.println(); } } } 输入5 输入8 Question 09 代码见./Q9/sort.java\npublic class sort { public static int[] qsort(int[] arr) { if(arr == null) { return null; } if(arr.length \u0026lt;= 1) { return arr; } int temp; for (int j = 0; j \u0026lt; arr.length - 1; j++) { for (int i = 0; i \u0026lt; arr.length - 1 - j; i++) { if (arr[i] \u0026gt; arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } return arr; } public static void main(String[] args) { int[] arr = new int[]{1, 3, 5, 7, 9, 2, 4, 6, 8}; qsort(arr); for (int j : arr) { System.out.print(j + \u0026#34; \u0026#34;); } } } Question 10 (1) 指出代码中注释标注出的四行输出的内容会是什么 p1 的 x, y 坐标: 1111, 2222 p2 的 x, y 坐标: -100, -200 p1 的 x, y 坐标: 0, 0 p2 的 x, y 坐标: 0, 0 (2) 什么是浅拷贝？什么是深拷贝？请你查阅一些资料，并给出你的资讯。 浅拷贝是指创建一个新对象，这个新对象的字段包含了原对象字段的精确副本，若字段是引用类型则复制地址，故对引用对象的操作会影响原对象。\n浅拷贝是指创建一个新对象，递归地复制所有引用类型字段所引用的对象。即使字段是引用类型，也会创建一个新副本，对其所有更改均不会影响原来的对象。\n(3) 如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。 可以在类中定义一个复制构造函数，通过该构造函数手动复制所有引用类型字段。\n解释String的 == 和 equals() 的区别。 ==仅检查引用的地址是否相同，即它们是否指向同一个对象；\nequals()检查字符串内容是否相同。\nQuestion 11 代码见./Q11/Variable.java\npackage Q11; public class Variable { public static String strscat(String... args) { String ss = \u0026#34;\u0026#34;; for(String x : args) { ss = ss + x; } return ss; } public static void main(String[] args) { System.out.println(strscat(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;)); System.out.println(strscat(\u0026#34;str\u0026#34;)); } } (1) 尝试理解 Java 可变参数的实现机制，说说你的想法。 可变参数实际上是将参数自动打包作为数组传递给方法。\n(2) 调用 strscat(new String[]{\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;}) 能通过编译吗？为什么？ 可以。本质上即手动将可变个参数打包为参数数组传递给方法。\n(3) 如果还有静态方法 String strscat(String[] args) 同时存在，代码能通过编译吗？给出 IDE 的编译结果的截图。 不能通过编译。\n(4) 如果我们声明的是 String strscat(String[] args)，strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;) 这样的调用还能通过编译吗？给出 IDE 的编译结果的截图。 Question 12 样例运行结果：\n代码见./Q12/BigNumberAddition.java\npackage Q12; import java.math.BigInteger; import java.util.Scanner; public class BigNumberAddition { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); BigInteger a = scanner.nextBigInteger(); BigInteger b = scanner.nextBigInteger(); // 计算它们的和 BigInteger sum = a.add(b); // 输出结果 System.out.println(sum); } } Question 13 代码见./Q13/Test.java\npackage Q13; class buyer { private String name; public buyer(String name) { this.name = name; } public void buy(String thing) { System.out.println(name + \u0026#34; 买了 \u0026#34; + thing); } } class chef { private String name; public chef(String name) { this.name = name; } public void cook(String thing) { System.out.println(name + \u0026#34; 做好了 \u0026#34; + thing); } } public class Test { public static void main(String[] args) { buyer aunt = new buyer(\u0026#34;姑姑\u0026#34;); buyer mom = new buyer(\u0026#34;妈妈\u0026#34;); buyer self = new buyer(\u0026#34;自己\u0026#34;); chef dad = new chef(\u0026#34;爸爸\u0026#34;); chef auntie = new chef(\u0026#34;婶婶\u0026#34;); aunt.buy(\u0026#34;鱼\u0026#34;); mom.buy(\u0026#34;羊肉\u0026#34;); self.buy(\u0026#34;蔬菜\u0026#34;); dad.cook(\u0026#34;葱爆羊肉\u0026#34;); auntie.cook(\u0026#34;豆腐鱼汤\u0026#34;); } } ","date":"2024-11-05T00:00:00Z","permalink":"https://charactex.com/post/2024/11/oop-lab01/","title":"北航软工: 面向对象程序设计 Lab01"},{"content":"介绍 priority_queue, 又称优先队列，是C++ STL库的重要组成部分之一。\npriority_queue的定义在头文件\u0026lt;queue\u0026gt;中，因此需要:\n#include \u0026lt;queue\u0026gt; 它允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面，标准库默认使用 \u0026lt; 操作符来确定优先级关系。\n它的原型是\ntemplate \u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt; \u0026gt; class priority_queue; 其中第一个为元素类型；第二个为承载优先队列的容器类型，一般是vector；第三个是比较函数。但由于后两个已经带有默认值，所以一般使用时只需要priority_queue\u0026lt;int\u0026gt;这样就行了。\n注：优先队列的优先级关系为值大的优先级高、值小的优先级低，而优先级高的放在队列前面，所以对于默认类型，它的内部元素总是从大到小的。\n常用操作 压入: push() 弹出: pop() 取队首元素: top() //与一般的队列不一样，不用front() 判空: empty() 取大小: size 样例程序 系统类型 //程序1 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; priority_queue\u0026lt;int\u0026gt; q; int main() { q.push(1); q.push(5); q.push(3); q.push(9); q.push(2); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } cout \u0026lt;\u0026lt; endl; return 0; } 这段程序的输出是：\n5 9 5 3 2 1 自定义类型 使用自定义类型，就要重载\u0026lt;运算符了。\n例:\n//程序2 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; struct node { int value; bool operator \u0026lt; (node x) const //const不能少 { return this -\u0026gt; value \u0026lt; x.value; } node(int _v): value(_v) {} }; int main() { priority_queue\u0026lt;node\u0026gt; q; q.push(node(3)); q.push(node(5)); q.push(node(10)); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { node tmp = q.top(); q.pop(); cout \u0026lt;\u0026lt; tmp.value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 10 5 3 改变优先级 系统类型 很多时候，我们需要由小到大排序，这时候就需要这样：\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt;pq; //三个int要一致！ 注：最后两个\u0026gt;号千万不要写在一起，否则有可能被编译器误认为是\u0026gt;\u0026gt;运算符！\n如果以这行代码替换上面程序1里的定义的话，运行结果就会是这样：\n5 1 2 3 5 9 自定义类型 自定义类型也是一个道理，但要重载\u0026gt;运算符：\nstruct node { int value; bool operator \u0026gt; (node x) const { return this -\u0026gt; value \u0026gt; x.value; } node(int _v): value(_v) {} }; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; q; //三个node也要一样！ 替换程序2相关内容，输出：\n3 3 5 10 ","date":"2018-06-28T00:00:00Z","permalink":"https://charactex.com/post/2018/06/priority_queue/","title":"C++ STL之priority_queue优先队列"}]