[{"content":" 题面与所有提及的文件均保存在作者的GitHub中，点击这里查看。\nLab 01 Assignment Question 01 包名命名为Q1，在命令行使用javac Q1/Main.java命令编译，并使用java Q1.Main命令运行生成的字节码。\nQuestion 02 基本类型 默认值 基本类型 默认值 byte 0 boolean false short 0 char 0 int 0 float 0.0 long 0 double 0.0 代码实现：\npublic class Main { byte b; short s; int i; long l; boolean bool; char c; float f; double d; public static void main(String[] args) { Main m = new Main(); System.out.println(\u0026#34;byte: \u0026#34; + m.b); System.out.println(\u0026#34;short: \u0026#34; + m.s); System.out.println(\u0026#34;int: \u0026#34; + m.i); System.out.println(\u0026#34;long: \u0026#34; + m.l); System.out.println(\u0026#34;bool: \u0026#34; + m.bool); System.out.println(\u0026#34;char: \u0026#34; + (int)m.c); System.out.println(\u0026#34;float: \u0026#34; + m.f); System.out.println(\u0026#34;double: \u0026#34; + m.d); } } 保存在./Q2/Main.java。\nQuestion 03 初步体现了面向对象编程思想，代码实现\npublic class FindMinMax { private static final double d1 = 1, d2 = -9.9, d3 = 96.9; public static double max() { double tmp; tmp = d1 \u0026gt; d2? d1 : d2; return (tmp \u0026gt; d3? tmp : d3); } public static double min() { double tmp; tmp = d1 \u0026lt; d2? d1 : d2; return (tmp \u0026lt; d3? tmp : d3); } public static void main(String[] args) { System.out.println(\u0026#34;max = \u0026#34; + max()); System.out.println(\u0026#34;min = \u0026#34; + min()); } } 保存在./Q3/FindMinMax.java，运行结果：\nmax = 96.9 min = -9.9 Question 04 运行结果：\n1 2 b is false 在main方法中，首先执行test1(0)，函数打印1并返回0 \u0026lt; 1的boolean值true；\n其次执行test2(2)，函数打印2并返回 2 \u0026lt; 2 的boolean值 false 。\n因为 test2(2) 为 false ，故 b = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2) 一定为false。由于短路机制的存在，将不会继续运行test3(2)函数，故没有在屏幕上输出3。\nQuestion 05 1. 上述源文件的名字是什么？ 答：Student.java\n2. 编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？ 答：生成 2 个字节码文件，文件名分别为Student.class与Exam.class。\n3. 执行以下命令并输出结果 （1）在命令行执行 java Student 得到怎样的错误提示？ Error: Main method not found in class Student, please define the main method as: public static void main(String[] args) or a JavaFX application class must extend javafx.application.Application （2）执行 java exam 得到怎样的错误提示？ Error: Could not find or load main class exam Caused by: java.lang.NoClassDefFoundError: exam (wrong name: Q5/Exam) （3）执行 java Exam.class 得到怎样的错误提示？ Error: Could not find or load main class Exam.class Caused by: java.lang.ClassNotFoundException: Exam.class （4）执行 java Exam 得到怎样的输出结果？ I am studying Java. Question 06 代码见./Q6/TwoDimensionArray.java\n运行结果：\nb[0][0] = 1000 sum = 1139 b.lengh = 3 arr1: 0 1 2 3 4 5 6 7 8 9 10 11 arr2: 0 1 2 3 4 5 6 7 8 9 10 11 arr3: 0 1 2 3 4 5 6 7 8 Question 07 题设代码： public class SwitchExample { public static void main (String[] args) { char c = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt;= 4; i++) { switch (i) { case 1: c = \u0026#39;J\u0026#39;; System.out.print(c); case 2: c = \u0026#39;e\u0026#39;; System.out.print(c); break; case 3: c = \u0026#39;p\u0026#39;; System.out.print(c); default: System.out.print(\u0026#34;好\u0026#34;); } } } } 运行结果： Jeep好好 原因分析： i = 1时，switch-case语句进入case 1，输出J；由于没有break语句，继续向下执行，输出e，然后break跳出switch-case，继续下一轮循环。\ni = 2时，switch-case语句进入case 2，输出e，之后遇到break语句，跳出switch-case，继续下一轮循环。\ni = 3时，switch-case语句进入case 3，输出p；由于没有break语句，继续向下执行default的内容，输出好。\ni = 4时，switch-case语句进入default，输出好；之后到达switch-case末尾，不再执行。\n故输出为Jeep好好。\nQuestion 08 代码见./Q8/nDimension.java\nimport java.util.Scanner; public class nDimension { public static void main(String[] args) { Scanner input = new Scanner(System.in); int n = input.nextInt(); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { System.out.print(++cnt + \u0026#34; \u0026#34;); } System.out.println(); } } } 输入5 输入8 Question 09 代码见./Q9/sort.java\npublic class sort { public static int[] qsort(int[] arr) { if(arr == null) { return null; } if(arr.length \u0026lt;= 1) { return arr; } int temp; for (int j = 0; j \u0026lt; arr.length - 1; j++) { for (int i = 0; i \u0026lt; arr.length - 1 - j; i++) { if (arr[i] \u0026gt; arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } return arr; } public static void main(String[] args) { int[] arr = new int[]{1, 3, 5, 7, 9, 2, 4, 6, 8}; qsort(arr); for (int j : arr) { System.out.print(j + \u0026#34; \u0026#34;); } } } Question 10 (1) 指出代码中注释标注出的四行输出的内容会是什么 p1 的 x, y 坐标: 1111, 2222 p2 的 x, y 坐标: -100, -200 p1 的 x, y 坐标: 0, 0 p2 的 x, y 坐标: 0, 0 (2) 什么是浅拷贝？什么是深拷贝？请你查阅一些资料，并给出你的资讯。 浅拷贝是指创建一个新对象，这个新对象的字段包含了原对象字段的精确副本，若字段是引用类型则复制地址，故对引用对象的操作会影响原对象。\n浅拷贝是指创建一个新对象，递归地复制所有引用类型字段所引用的对象。即使字段是引用类型，也会创建一个新副本，对其所有更改均不会影响原来的对象。\n(3) 如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。 可以在类中定义一个复制构造函数，通过该构造函数手动复制所有引用类型字段。\n解释String的 == 和 equals() 的区别。 ==仅检查引用的地址是否相同，即它们是否指向同一个对象；\nequals()检查字符串内容是否相同。\nQuestion 11 代码见./Q11/Variable.java\npackage Q11; public class Variable { public static String strscat(String... args) { String ss = \u0026#34;\u0026#34;; for(String x : args) { ss = ss + x; } return ss; } public static void main(String[] args) { System.out.println(strscat(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;)); System.out.println(strscat(\u0026#34;str\u0026#34;)); } } (1) 尝试理解 Java 可变参数的实现机制，说说你的想法。 可变参数实际上是将参数自动打包作为数组传递给方法。\n(2) 调用 strscat(new String[]{\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;}) 能通过编译吗？为什么？ 可以。本质上即手动将可变个参数打包为参数数组传递给方法。\n(3) 如果还有静态方法 String strscat(String[] args) 同时存在，代码能通过编译吗？给出 IDE 的编译结果的截图。 不能通过编译。\n(4) 如果我们声明的是 String strscat(String[] args)，strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;) 这样的调用还能通过编译吗？给出 IDE 的编译结果的截图。 Question 12 样例运行结果：\n代码见./Q12/BigNumberAddition.java\npackage Q12; import java.math.BigInteger; import java.util.Scanner; public class BigNumberAddition { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); BigInteger a = scanner.nextBigInteger(); BigInteger b = scanner.nextBigInteger(); // 计算它们的和 BigInteger sum = a.add(b); // 输出结果 System.out.println(sum); } } Question 13 代码见./Q13/Test.java\npackage Q13; class buyer { private String name; public buyer(String name) { this.name = name; } public void buy(String thing) { System.out.println(name + \u0026#34; 买了 \u0026#34; + thing); } } class chef { private String name; public chef(String name) { this.name = name; } public void cook(String thing) { System.out.println(name + \u0026#34; 做好了 \u0026#34; + thing); } } public class Test { public static void main(String[] args) { buyer aunt = new buyer(\u0026#34;姑姑\u0026#34;); buyer mom = new buyer(\u0026#34;妈妈\u0026#34;); buyer self = new buyer(\u0026#34;自己\u0026#34;); chef dad = new chef(\u0026#34;爸爸\u0026#34;); chef auntie = new chef(\u0026#34;婶婶\u0026#34;); aunt.buy(\u0026#34;鱼\u0026#34;); mom.buy(\u0026#34;羊肉\u0026#34;); self.buy(\u0026#34;蔬菜\u0026#34;); dad.cook(\u0026#34;葱爆羊肉\u0026#34;); auntie.cook(\u0026#34;豆腐鱼汤\u0026#34;); } } ","date":"2024-11-05T00:00:00Z","permalink":"https://charactex.com/post/2024/11/oop-lab01/","title":"北航软工: 面向对象程序设计 Lab01"},{"content":"介绍 priority_queue, 又称优先队列，是C++ STL库的重要组成部分之一。\npriority_queue的定义在头文件\u0026lt;queue\u0026gt;中，因此需要:\n#include \u0026lt;queue\u0026gt; 它允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面，标准库默认使用 \u0026lt; 操作符来确定优先级关系。\n它的原型是\ntemplate \u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt; \u0026gt; class priority_queue; 其中第一个为元素类型；第二个为承载优先队列的容器类型，一般是vector；第三个是比较函数。但由于后两个已经带有默认值，所以一般使用时只需要priority_queue\u0026lt;int\u0026gt;这样就行了。\n注：优先队列的优先级关系为值大的优先级高、值小的优先级低，而优先级高的放在队列前面，所以对于默认类型，它的内部元素总是从大到小的。\n常用操作 压入: push() 弹出: pop() 取队首元素: top() //与一般的队列不一样，不用front() 判空: empty() 取大小: size 样例程序 系统类型 //程序1 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; priority_queue\u0026lt;int\u0026gt; q; int main() { q.push(1); q.push(5); q.push(3); q.push(9); q.push(2); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } cout \u0026lt;\u0026lt; endl; return 0; } 这段程序的输出是：\n5 9 5 3 2 1 自定义类型 使用自定义类型，就要重载\u0026lt;运算符了。\n例:\n//程序2 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; struct node { int value; bool operator \u0026lt; (node x) const //const不能少 { return this -\u0026gt; value \u0026lt; x.value; } node(int _v): value(_v) {} }; int main() { priority_queue\u0026lt;node\u0026gt; q; q.push(node(3)); q.push(node(5)); q.push(node(10)); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { node tmp = q.top(); q.pop(); cout \u0026lt;\u0026lt; tmp.value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 10 5 3 改变优先级 系统类型 很多时候，我们需要由小到大排序，这时候就需要这样：\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt;pq; //三个int要一致！ 注：最后两个\u0026gt;号千万不要写在一起，否则有可能被编译器误认为是\u0026gt;\u0026gt;运算符！\n如果以这行代码替换上面程序1里的定义的话，运行结果就会是这样：\n5 1 2 3 5 9 自定义类型 自定义类型也是一个道理，但要重载\u0026gt;运算符：\nstruct node { int value; bool operator \u0026gt; (node x) const { return this -\u0026gt; value \u0026gt; x.value; } node(int _v): value(_v) {} }; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; q; //三个node也要一样！ 替换程序2相关内容，输出：\n3 3 5 10 ","date":"2018-06-28T00:00:00Z","permalink":"https://charactex.com/post/2018/06/priority_queue/","title":"C++ STL之priority_queue优先队列"}]