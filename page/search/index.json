[{"content":"Lab 3 Lab 3 Problem Set 题面附件代码见https://github.com/charcai/BUAA-OOP-2024/tree/main/Lab03/Lab3-Code\n解答代码见https://github.com/charcai/BUAA-OOP-2024/tree/main/Lab03/\nQuestion1: Package 浏览 Code 目录下的 Question01 目录，不允许变更目录结构和文件位置，只允许在文件中添加 package 和 import 语句，使根目录下 build 和 test 文件中的指令可以无报错顺利执行。\nbuild 和 test 为脚本文件，直接在 IDE 或文本编辑器中打开即可看到其中的指令。\nPS.不要轻易相信IDEA自动加的，报红的是可以通过编译运行的\n你可以把 Question01 目录复制到解答的压缩包中，或者在解答报告中直接以文字或截图说明你的改动。\nQuestion2：方法重写 阅读 Code 目录下的 Question02 目录，根据你对方法重写规则的理解，回答下列问题并改正代码错误\nWorker.java 的 1 号注释处正确吗，如果不正确应该怎么改正，为什么？ 如果 Worker.java 内 eat() 方法的修饰符改为 private，可以通过编译吗，为什么？ Teacher.java 的 2 号注释处正确吗，如果不正确应该怎么改正，为什么？ Teacher.java 的 3 号注释处正确吗，如果不正确应该怎么改正，为什么？ 属性、静态方法、非静态方法，哪些可以覆盖（重写 / override），哪些可以隐藏？ 你可以把 Question02 目录复制到解答的压缩包中，或者在解答报告中直接以文字或截图说明你的改动。\nQuestion3: super VS this 完成下面表格，复制或截图在解答报告中\n区别点 this super 引用（代表什么） 使用方式 调用构造方法（调用谁的构造方法，放在第几条语句） 查找范围（查找顺序） Question4: final 在实验报告中回答下列问题\nfinal 修饰的类可以被继承吗？可以继承其它类吗？ final 修饰的方法可以被重写吗？ final 修饰的变量相当于什么？ final 修饰的引用类型变量可以改变其引用地址吗？可以改变对象的内部属性的值吗？ Question5: 权限 阅读 Code 目录下的 Question05 目录，根据你对访问权限的理解。将文件中所有无法通过编译的语句注释掉。\n你遇到的问题可能会集中在 protected 和默认访问权限。 从这次实验和上一次实验，可以引申出两个问题，你需要在解答中说出你的想法。\nLab 2 中的单例模式，或者说所有构造方法都是 private 时，可能有子类吗？ final 类可以视为所有构造方法都是 private 的类吗？ 你可以把 Question05 目录复制到解答的压缩包中，或者在解答报告中直接以文字或截图说明你的改动。\nQuestion6: Shape 阅读下面的二维形状类 Shape\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class Shape { protected double a; protected double b; public Shape() { this(0.0, 0.0); } public Shape(double a, double b) { this.a = a; this.b = b; } /** calcArea * 计算形状的面积 * @return 面积 */ abstract public double calcArea(); /* 其他必要的方法，比如 getter 和 setter */ } 你的任务是：\n编写 Rectangle 类，a 和 b 分别代表矩形两条边的长度（长和宽）； 编写 Rhombus 类，a 和 b 分别代表两条菱形对角线的长度； 编写 Ellipse 类，a 和 b 分别代表椭圆两个半轴（半长轴和半短轴）的长度； 编写一个测试类，构造子类对象并测试。 注意：\n上述三个类都继承自 Shape 类，都必须要 override 方法 calcArea； a 和 b 都不能是负数，当通过 constructor 或者 setter 设定为负数时，将对应的值置为 0.0，或 throw 异常； a 和 b 的大小关系没有任何约束，没有 a 必须不小于 b 的说法。 题外话\n我们知道属性不设置为 public 是为了保护数据，如果 a 和 b 在 Shape 中的访问权限被设置为 private，在不添加新的属性的情况下，子类想要实现自己的 calcArea()该怎么办？在解答中写出你的思考。\nQuestion7: 车车 定义一个 Vehicle 类，在其中声明一个属性代表这个交通工具有多少个轮子，提供对这个属性的 setter。提供轮子类、引擎类。创建几个 Vehicle 的导出类：Motorbike、Car、Tank。自由发挥，在测试类中构造这几种交通工具，并测试功能。\n其中 Motorbike 类需增加两个属性：driver 和 passenger 表示司机和乘客。增加你觉得合适的方法。\n定义一个 Person 类，加入你觉得合适的属性和方法，生成 brother 和 sister 两个对象，结合 Motorbike 试图实现以下场景：\n生成三个对象（Motorbike 实例 motorbike，Person 实例 brother、sister） 设置 motorbike 的司机与乘客为 brother 和 sister 打印 motorbike 的信息（尽可能详细） 调用 sister 的 say() 方法，输出“不像我，我只会心疼 giegie~” 备注：这道题目绝不是 2321 同学们的助教出的。\nLab 3 Assignment Question1 代码打包为文件夹，见 ./Question01/ 目录。\nQuestion2 修改后的文件见./Question02/。\nWorker.java 的 1 号注释处正确吗，如果不正确应该怎么改正，为什么？\n不正确。 可以将 @Override 行删除。\nWorker.eat() 与 People.eat() 所传递的参数不同，构成 Overload 而非 Override，故签名不正确。\n如果 Worker.java 内 eat() 方法的修饰符改为 private，可以通过编译吗，为什么？\n不可以。 在 Java 中，子类 Override 的方法不能比父类中被 Override 的方法有更低的访问级别。\nTeacher.java的 2 号注释处正确吗，如果不正确应该怎么改正，为什么？\n不正确。 在 Java 中，子类 Override 的方法应与父类中被 Override 的方法有相同的返回类型。本代码中，Teacher.work() 返回类型是People，而 Worker.work() 返回类型是 Worker。\n可将 Teacher.work() 的返回类型改为 Worker, 将返回值改为 return new Worker();。\nTeacher.java 的 3 号注释处正确吗，如果不正确应该怎么改正，为什么？\n不正确。 问题同上，在 Java 中，子类 Override 的方法应与父类中被 Override 的方法有相同的返回类型。\n可将 Worker.salary() 的返回类型改为 long。\n属性、静态方法、非静态方法，哪些可以覆盖（重写 / override），哪些可以隐藏？\n属性不能被覆盖，可以被隐藏。 静态方法不能被覆盖，可以被隐藏。 非静态方法可以被覆盖，不能被隐藏。 Question3 区别点 this super 引用 当前对象的引用 父类对象的引用 使用方式 用于访问当前对象的成员变量和方法 用于访问当前对象的成员变量和方法 调用构造方法 调用当前类的其他构造方法，必须放在构造方法的第一条语句 调用父类的构造方法，必须放在构造方法的第一条语句 查找范围 从当前类开始查找 从父类开始查找 Question4 final 修饰的类可以被继承吗？可以继承其它类吗？\nfinal 修饰的类不能被继承，可以继承其它类。\nfinal 修饰的方法可以被重写吗？\nfinal 修饰的方法不可以被重写。\nfinal 修饰的变量相当于什么？\n相当于常量。\nfinal 修饰的引用类型变量可以改变其引用地址吗？可以改变对象的内部属性的值吗？\nfinal 修饰的引用类型变量不可以改变其引用地址，可以改变对象的内部属性的值。\nQuestion5 修改后的代码见 ./Question 05/ 目录。\n解答:\nLab 2 中的单例模式，或者说所有构造方法都是 private 时，不可能有子类。 final 类不完全可以视为所有构造方法都是 private 的类。二者都不能被继承、不能被扩展，但区别在于，final 类在有 public 或 protected 的构造方法时可以被实例化，而所有构造方法都是 private 的类不能被外部实例化。 Question6 工程文件见 ./Question06/目录。\n思考题： 如果 a 和 b 在 Shape 中的访问权限被设置为 private，在不添加新的属性的情况下，子类想要实现自己的 calcArea() 该怎么办？\n可以在 Shape 中实现两个方法 getA() 与 getB()， 返回 a 和 b 的值，便可直接被外部方法调用。\nQuestion7 工程文件见 ./Question07/ 目录。\n交通工具的测试类为 ./Question07/TestVehicles.java， 场景的测试类为./Question07/TestMotorbike.java。 ","date":"2024-12-05T00:00:00Z","permalink":"https://charactex.com/post/2024/12/oop-lab03/","title":"北航软工: 面向对象程序设计 Lab 3"},{"content":"Lab 2 Assignment 题面与所有提及的文件均保存在作者的GitHub中，点击这里查看。\nQuestion 01 1. 注释标记的哪些行会导致编译错误？将错误截图，并说明原因。 第 4 行会编译错误。\n在方法中声明的变量需手动设置初始值后方可正常调用，此处 m 没有赋初始值。\n2. 区分变量 x 和 m ，回答谁需要初始化才能使用，为什么 m需要初始化才能使用，因为它是声明在方法中的局部变量。\nx不需初始化即可使用，因为它是声明在类中的全局变量。\nQuestion 02 a. Overload(int m) 与 Overload(double m) 互为重载的构造方法。 正确。\nb. int Overload(int m) 与 void Overload(double m) 互为重载的非构造方法。 正确。\nc. Overload 类有 2 个构造方法，尝试调用默认构造方法 Overload() 会无法通过编译。 正确。\nd. Overload 类有 3 个构造方法。 错误。构造方法无返回值类型，只有前两个方法是合法的构造方法。\nQuestion 03 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 initialize A1 initialize A2 initialize A3 initialize A4 initialize A5 initialize A6 copy from A6 initialize B1 initialize A8 main begins initialize A9 initialize A6 copy from A6 initialize B2 initialize A8 main ends Question 04 1. 这段代码能够证明“在属性定义处初始化的属性，比在方法中初始化的属性先被初始化”吗？ 能。 a7在属性定义处初始化，a8在方法中初始化，尽管a7出现于a8之后，依然被先初始化。\n2. 这段代码能够证明“在属性定义处初始化的属性，初始化顺序等同于他们在类定义 中出现的顺序”吗？\n能。 a6、a7两个非静态属性先后出现，二者也是按照出现顺序先后被初始化。\nQuestion 05 静态属性的初始化顺序均与出现顺序相同，无论是静态变量还是静态初始化块。\n静态变量 静态变量在类加载时初始化。它们按照在类中出现的顺序进行初始化。 静态初始化块 静态初始化块在静态变量初始化同时执行。多个静态初始化块按照它们在类中出现的顺序依次执行。 a3, a4, a5中，a3，a5是静态变量、a4在静态初始化块中被初始化，三者均按照出现顺序a3 - a4 - a5被初始化。\nQuestion 06 1. 这段代码能够证明“在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”吗？如果不能，请尝试修改代码并证明。 不能。 需要在每个类的起始处打印执行的提示信息，修改后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { static { System.out.println(\u0026#34;Class A is being loaded\u0026#34;); } int value; static A a1 = new A(1); public A(int i) { System.out.println(\u0026#34;initialize A\u0026#34; + i); value = i; } public A(A a) { System.out.println(\u0026#34;copy from A\u0026#34; + a.value); value = a.value; } static A a2 = new A(2); } class B { static { System.out.println(\u0026#34;Class B is being loaded\u0026#34;); } A a8; // A a7 = new A(a6); A a6 = new A(6); static A a3 = new A(3); static A a4; static { a4 = new A(4); } static A a5 = new A(5); public B(int i) { System.out.println(\u0026#34;initialize B\u0026#34; + i); a8 = new A(8); } A a7 = new A(a6); } public class Initialization { static { System.out.println(\u0026#34;Class Initialization is being loaded\u0026#34;); } static B b1 = new B(1); static B b2; public static void main(String[] args) { System.out.println(\u0026#34;main begins\u0026#34;); A a9 = new A(9); b2 = new B(2); System.out.println(\u0026#34;main ends\u0026#34;); } } 该程序编译运行后输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Class Initialization is being loaded Class B is being loaded Class A is being loaded initialize A1 initialize A2 initialize A3 initialize A4 initialize A5 initialize A6 copy from A6 initialize B1 initialize A8 main begins initialize A9 initialize A6 copy from A6 initialize B2 initialize A8 main ends 由前三行可知，类被加载的顺序是Initialization, B, A, 与三者第一次被加载的顺序一致，故可以证明“在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”。\n2. 基于static关键字，带有static关键字的方法、变量、代码块可以调用什么？反过来，不带有static关键字的方法、变量、代码块可以调用什么？(带有static关键字的方法、变量 or 不带有static关键字的方法、变量 or 都可以) 带有static关键字的方法、变量、代码块只能调用其他带有static关键字的方法、变量、代码块。\n不带有static关键字的方法、变量、代码块可以调用带有static关键字的方法、变量、代码块，也可以调用其他不带static关键字的方法、变量、代码块。\nQuestion 07 不可以，其他的外部类不能通过 new Singleton() 来构造一个新的 Singleton 变量。\nQuestion 08 因为 Singleton 类的构造方法是私有的，此类只能在 Singleton 类的内部被调用。外部类无法访问这个私有构造方法，因此无法创造更多实例，最多只可能有由 Singleton 类自己创造的 1 个实例同时存在。\n唯一实例在第一次调用 getInstance() 方法时被构造。\nQuestion 09 下列代码可以从外部调用 Singleton 类的 foo()：\n1 2 3 4 5 6 7 8 9 public class TestSingleton { public static void main(String[] args) { // 获取 Singleton 类的唯一实例 Singleton singletonInstance = Singleton.getInstance(); // 调用 Singleton 类的 foo() 方法 singletonInstance.foo(); } } Question 10 代码见./Q10/TestPerson.java, 点此跳转\nQuestion 11 代码见./Q11/Solution.java, 点此跳转\n","date":"2024-11-06T00:00:00Z","permalink":"https://charactex.com/post/2024/11/oop-lab02/","title":"北航软工: 面向对象程序设计 Lab 2"},{"content":" 题面与所有提及的文件均保存在作者的GitHub中，点击这里查看。\nLab 1 Assignment Question 01 包名命名为Q1，在命令行使用javac Q1/Main.java命令编译，并使用java Q1.Main命令运行生成的字节码。\nQuestion 02 基本类型 默认值 基本类型 默认值 byte 0 boolean false short 0 char 0 int 0 float 0.0 long 0 double 0.0 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { byte b; short s; int i; long l; boolean bool; char c; float f; double d; public static void main(String[] args) { Main m = new Main(); System.out.println(\u0026#34;byte: \u0026#34; + m.b); System.out.println(\u0026#34;short: \u0026#34; + m.s); System.out.println(\u0026#34;int: \u0026#34; + m.i); System.out.println(\u0026#34;long: \u0026#34; + m.l); System.out.println(\u0026#34;bool: \u0026#34; + m.bool); System.out.println(\u0026#34;char: \u0026#34; + (int)m.c); System.out.println(\u0026#34;float: \u0026#34; + m.f); System.out.println(\u0026#34;double: \u0026#34; + m.d); } } 保存在./Q2/Main.java。\nQuestion 03 初步体现了面向对象编程思想，代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class FindMinMax { private static final double d1 = 1, d2 = -9.9, d3 = 96.9; public static double max() { double tmp; tmp = d1 \u0026gt; d2? d1 : d2; return (tmp \u0026gt; d3? tmp : d3); } public static double min() { double tmp; tmp = d1 \u0026lt; d2? d1 : d2; return (tmp \u0026lt; d3? tmp : d3); } public static void main(String[] args) { System.out.println(\u0026#34;max = \u0026#34; + max()); System.out.println(\u0026#34;min = \u0026#34; + min()); } } 保存在./Q3/FindMinMax.java，运行结果：\n1 2 max = 96.9 min = -9.9 Question 04 运行结果：\n1 2 3 1 2 b is false 在main方法中，首先执行test1(0)，函数打印1并返回0 \u0026lt; 1的boolean值true；\n其次执行test2(2)，函数打印2并返回 2 \u0026lt; 2 的boolean值 false 。\n因为 test2(2) 为 false ，故 b = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2) 一定为false。由于短路机制的存在，将不会继续运行test3(2)函数，故没有在屏幕上输出3。\nQuestion 05 1. 上述源文件的名字是什么？ 答：Student.java\n2. 编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？ 答：生成 2 个字节码文件，文件名分别为Student.class与Exam.class。\n3. 执行以下命令并输出结果 （1）在命令行执行 java Student 得到怎样的错误提示？ 1 2 3 Error: Main method not found in class Student, please define the main method as: public static void main(String[] args) or a JavaFX application class must extend javafx.application.Application （2）执行 java exam 得到怎样的错误提示？ 1 2 Error: Could not find or load main class exam Caused by: java.lang.NoClassDefFoundError: exam (wrong name: Q5/Exam) （3）执行 java Exam.class 得到怎样的错误提示？ 1 2 Error: Could not find or load main class Exam.class Caused by: java.lang.ClassNotFoundException: Exam.class （4）执行 java Exam 得到怎样的输出结果？ 1 I am studying Java. Question 06 代码见./Q6/TwoDimensionArray.java\n运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 b[0][0] = 1000 sum = 1139 b.lengh = 3 arr1: 0 1 2 3 4 5 6 7 8 9 10 11 arr2: 0 1 2 3 4 5 6 7 8 9 10 11 arr3: 0 1 2 3 4 5 6 7 8 Question 07 题设代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SwitchExample { public static void main (String[] args) { char c = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt;= 4; i++) { switch (i) { case 1: c = \u0026#39;J\u0026#39;; System.out.print(c); case 2: c = \u0026#39;e\u0026#39;; System.out.print(c); break; case 3: c = \u0026#39;p\u0026#39;; System.out.print(c); default: System.out.print(\u0026#34;好\u0026#34;); } } } } 运行结果： 1 Jeep好好 原因分析： i = 1时，switch-case语句进入case 1，输出J；由于没有break语句，继续向下执行，输出e，然后break跳出switch-case，继续下一轮循环。\ni = 2时，switch-case语句进入case 2，输出e，之后遇到break语句，跳出switch-case，继续下一轮循环。\ni = 3时，switch-case语句进入case 3，输出p；由于没有break语句，继续向下执行default的内容，输出好。\ni = 4时，switch-case语句进入default，输出好；之后到达switch-case末尾，不再执行。\n故输出为Jeep好好。\nQuestion 08 代码见./Q8/nDimension.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import java.util.Scanner; public class nDimension { public static void main(String[] args) { Scanner input = new Scanner(System.in); int n = input.nextInt(); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { System.out.print(++cnt + \u0026#34; \u0026#34;); } System.out.println(); } } } 输入5 输入8 Question 09 代码见./Q9/sort.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class sort { public static int[] qsort(int[] arr) { if(arr == null) { return null; } if(arr.length \u0026lt;= 1) { return arr; } int temp; for (int j = 0; j \u0026lt; arr.length - 1; j++) { for (int i = 0; i \u0026lt; arr.length - 1 - j; i++) { if (arr[i] \u0026gt; arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } return arr; } public static void main(String[] args) { int[] arr = new int[]{1, 3, 5, 7, 9, 2, 4, 6, 8}; qsort(arr); for (int j : arr) { System.out.print(j + \u0026#34; \u0026#34;); } } } Question 10 (1) 指出代码中注释标注出的四行输出的内容会是什么 p1 的 x, y 坐标: 1111, 2222 p2 的 x, y 坐标: -100, -200 p1 的 x, y 坐标: 0, 0 p2 的 x, y 坐标: 0, 0 (2) 什么是浅拷贝？什么是深拷贝？请你查阅一些资料，并给出你的资讯。 浅拷贝是指创建一个新对象，这个新对象的字段包含了原对象字段的精确副本，若字段是引用类型则复制地址，故对引用对象的操作会影响原对象。\n浅拷贝是指创建一个新对象，递归地复制所有引用类型字段所引用的对象。即使字段是引用类型，也会创建一个新副本，对其所有更改均不会影响原来的对象。\n(3) 如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。 可以在类中定义一个复制构造函数，通过该构造函数手动复制所有引用类型字段。\n解释String的 == 和 equals() 的区别。 ==仅检查引用的地址是否相同，即它们是否指向同一个对象；\nequals()检查字符串内容是否相同。\nQuestion 11 代码见./Q11/Variable.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package Q11; public class Variable { public static String strscat(String... args) { String ss = \u0026#34;\u0026#34;; for(String x : args) { ss = ss + x; } return ss; } public static void main(String[] args) { System.out.println(strscat(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;)); System.out.println(strscat(\u0026#34;str\u0026#34;)); } } (1) 尝试理解 Java 可变参数的实现机制，说说你的想法。 可变参数实际上是将参数自动打包作为数组传递给方法。\n(2) 调用 strscat(new String[]{\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;}) 能通过编译吗？为什么？ 可以。本质上即手动将可变个参数打包为参数数组传递给方法。\n(3) 如果还有静态方法 String strscat(String[] args) 同时存在，代码能通过编译吗？给出 IDE 的编译结果的截图。 不能通过编译。\n(4) 如果我们声明的是 String strscat(String[] args)，strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;) 这样的调用还能通过编译吗？给出 IDE 的编译结果的截图。 Question 12 样例运行结果：\n代码见./Q12/BigNumberAddition.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package Q12; import java.math.BigInteger; import java.util.Scanner; public class BigNumberAddition { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); BigInteger a = scanner.nextBigInteger(); BigInteger b = scanner.nextBigInteger(); // 计算它们的和 BigInteger sum = a.add(b); // 输出结果 System.out.println(sum); } } Question 13 代码见./Q13/Test.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package Q13; class buyer { private String name; public buyer(String name) { this.name = name; } public void buy(String thing) { System.out.println(name + \u0026#34; 买了 \u0026#34; + thing); } } class chef { private String name; public chef(String name) { this.name = name; } public void cook(String thing) { System.out.println(name + \u0026#34; 做好了 \u0026#34; + thing); } } public class Test { public static void main(String[] args) { buyer aunt = new buyer(\u0026#34;姑姑\u0026#34;); buyer mom = new buyer(\u0026#34;妈妈\u0026#34;); buyer self = new buyer(\u0026#34;自己\u0026#34;); chef dad = new chef(\u0026#34;爸爸\u0026#34;); chef auntie = new chef(\u0026#34;婶婶\u0026#34;); aunt.buy(\u0026#34;鱼\u0026#34;); mom.buy(\u0026#34;羊肉\u0026#34;); self.buy(\u0026#34;蔬菜\u0026#34;); dad.cook(\u0026#34;葱爆羊肉\u0026#34;); auntie.cook(\u0026#34;豆腐鱼汤\u0026#34;); } } ","date":"2024-11-05T00:00:00Z","permalink":"https://charactex.com/post/2024/11/oop-lab01/","title":"北航软工: 面向对象程序设计 Lab 1"},{"content":"介绍 priority_queue, 又称优先队列，是C++ STL库的重要组成部分之一。\npriority_queue的定义在头文件\u0026lt;queue\u0026gt;中，因此需要:\n1 #include \u0026lt;queue\u0026gt; 它允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面，标准库默认使用 \u0026lt; 操作符来确定优先级关系。\n它的原型是\n1 2 template \u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt; \u0026gt; class priority_queue; 其中第一个为元素类型；第二个为承载优先队列的容器类型，一般是vector；第三个是比较函数。但由于后两个已经带有默认值，所以一般使用时只需要priority_queue\u0026lt;int\u0026gt;这样就行了。\n注：优先队列的优先级关系为值大的优先级高、值小的优先级低，而优先级高的放在队列前面，所以对于默认类型，它的内部元素总是从大到小的。\n常用操作 压入: push() 弹出: pop() 取队首元素: top() //与一般的队列不一样，不用front() 判空: empty() 取大小: size 样例程序 系统类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //程序1 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; priority_queue\u0026lt;int\u0026gt; q; int main() { q.push(1); q.push(5); q.push(3); q.push(9); q.push(2); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } cout \u0026lt;\u0026lt; endl; return 0; } 这段程序的输出是：\n1 2 5 9 5 3 2 1 自定义类型 使用自定义类型，就要重载\u0026lt;运算符了。\n例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //程序2 #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; struct node { int value; bool operator \u0026lt; (node x) const //const不能少 { return this -\u0026gt; value \u0026lt; x.value; } node(int _v): value(_v) {} }; int main() { priority_queue\u0026lt;node\u0026gt; q; q.push(node(3)); q.push(node(5)); q.push(node(10)); cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; while(!q.empty()) { node tmp = q.top(); q.pop(); cout \u0026lt;\u0026lt; tmp.value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 10 5 3 改变优先级 系统类型 很多时候，我们需要由小到大排序，这时候就需要这样：\n1 2 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt;pq; //三个int要一致！ 注：最后两个\u0026gt;号千万不要写在一起，否则有可能被编译器误认为是\u0026gt;\u0026gt;运算符！\n如果以这行代码替换上面程序1里的定义的话，运行结果就会是这样：\n1 2 5 1 2 3 5 9 自定义类型 自定义类型也是一个道理，但要重载\u0026gt;运算符：\n1 2 3 4 5 6 7 8 9 10 11 struct node { int value; bool operator \u0026gt; (node x) const { return this -\u0026gt; value \u0026gt; x.value; } node(int _v): value(_v) {} }; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; q; //三个node也要一样！ 替换程序2相关内容，输出：\n1 2 3 3 5 10 ","date":"2018-06-28T00:00:00Z","permalink":"https://charactex.com/post/2018/06/priority_queue/","title":"C++ STL之priority_queue优先队列"}]